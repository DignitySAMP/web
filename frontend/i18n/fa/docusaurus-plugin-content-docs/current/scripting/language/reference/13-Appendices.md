# ضمیمه‌ها

---

## پیام‌های خطا و هشدار

---

هنگامی که کامپایلر خطایی را در یک فایل پیدا می‌کند، پیامی را به این ترتیب نمایش می‌دهد:

- نام فایل

- شماره خط که کامپایلر خطا را در آن تشخیص داده است در پرانتز، مستقیماً پشت نام فایل

- کلاس خطا ("error"، "fatal error" یا "warning")

- یک شماره خطا

- یک پیام خطای توصیفی

برای مثال:

    demo.p(3) : error 001: expected token: ";", but found "\{"

توجه: شماره خط ارائه شده توسط کامپایلر ممکن است موقعیتی پشت
خطای واقعی را مشخص کند، زیرا کامپایلر همیشه نمی‌تواند یک خطا را قبل از تجزیه
کامل عبارت تشخیص دهد.

پس از خاتمه، کد بازگشتی کامپایلر به شرح زیر است:

    0   بدون خطا —اگرچه ممکن است هشدارهایی وجود داشته باشد
    1   خطاها یافت شدند
    2   رزرو شده
    3   توسط کاربر لغو شد

این کدهای بازگشتی ممکن است در پردازنده‌های دسته‌ای (مانند ابزار "make") بررسی شوند.

### • دسته‌بندی‌های خطا

خطاها به سه دسته تقسیم می‌شوند:

| نوع | توضیحات |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------- |
| خطاها | مواردی را توصیف می‌کنند که کامپایلر قادر به تولید کد مناسب نیست. پیام‌های خطا از 1 تا 99 شماره‌گذاری شده‌اند. |
| خطاهای مهلک | خطاهای مهلک، خطاهایی را توصیف می‌کنند که کامپایلر نمی‌تواند از آنها بازیابی شود. تجزیه لغو می‌شود. پیام‌های خطای مهلک از 100 تا 199 شماره‌گذاری شده‌اند. |
| هشدارها | هشدارها برای فرضیات ناخواسته کامپایلر و اشتباهات رایج نمایش داده می‌شوند. پیام‌های هشدار از 200 تا 299 شماره‌گذاری شده‌اند. |

### • خطاها

| شماره | توضیحات |
| ------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 001 | **توکن مورد انتظار:** _token_, **اما یافت شد** _token_ |
| | یک توکن مورد نیاز حذف شده است. |
| 002 | **فقط یک دستور (یا عبارت) می‌تواند پس از هر "case" قرار گیرد** |
| | هر case در یک دستور switch می‌تواند دقیقاً یک دستور داشته باشد. برای قرار دادن چندین دستور در یک case، این دستورات را بین آکولادها قرار دهید (که یک دستور مرکب ایجاد می‌کند). |
| 003 | **اعلان یک متغیر محلی باید در یک بلوک مرکب ظاهر شود** |
| | اعلان یک متغیر محلی باید بین آکولادها ("\{. . . \}") در سطح دامنه فعال قرار گیرد. |
| | هنگامی که پارسر این خطا را نشان می‌دهد، یک اعلان متغیر به عنوان تنها دستور یک تابع یا تنها دستور زیر یک دستور if، else، for، while یا do ظاهر می‌شود. توجه داشته باشید که از آنجا که متغیرهای محلی فقط از (یا زیر) دامنه‌ای که اعلان آنها در آن ظاهر می‌شود قابل دسترسی هستند، داشتن یک اعلان متغیر به عنوان تنها دستور در هر دامنه بی‌فایده است. |
| 004 | **تابع** _name_ **پیاده‌سازی نشده است** |
| | هیچ پیاده‌سازی برای تابع مشخص شده وجود ندارد. ممکن است تابع به صورت "رو به جلو" اعلام شده باشد —یا نمونه اولیه شده باشد— اما تعریف کامل تابع شامل یک دستور، یا بلوک دستور، وجود ندارد. |
| 005 | **تابع نمی‌تواند آرگومان داشته باشد** |
| | تابع main() نقطه ورود برنامه است. نمی‌تواند آرگومان داشته باشد. |
| 006 | **باید به یک آرایه اختصاص داده شود** |
| | رشته‌های لیترال یا آرایه‌ها باید به یک آرایه اختصاص داده شوند. این پیام خطا همچنین ممکن است نشان‌دهنده یک شاخص (یا شاخص‌های) از دست رفته در آرایه در سمت راست علامت "=" باشد. |
| 007 | **عملگر نمی‌تواند بازتعریف شود** |
| | فقط مجموعه‌ای انتخابی از عملگرها می‌توانند بازتعریف شوند، این عملگر یکی از آنها نیست. برای جزئیات به صفحه 86 مراجعه کنید. |
| 008 | **باید یک عبارت ثابت باشد؛ صفر فرض شده است** |
| | اندازه آرایه‌ها و پارامترهای اکثر دستورالعمل‌ها باید مقادیر ثابت باشند. |
| 009 | **اندازه آرایه نامعتبر (منفی یا صفر)** |
| | تعداد عناصر یک آرایه همیشه باید 1 یا بیشتر باشد. |
| 010 | **تابع یا اعلان غیرقانونی** |
| | کامپایلر در موقعیت فعلی انتظار اعلان یک متغیر جهانی یا یک تابع را دارد، اما نمی‌تواند آن را به عنوان چنین چیزی تفسیر کند. |
| 011 | **خارج از توابع نامعتبر است** |
| | دستورالعمل یا دستور در سطح جهانی نامعتبر است. برچسب‌های محلی و دستورات (مرکب) فقط در صورت استفاده در توابع معتبر هستند. |
| 012 | **فراخوانی تابع نامعتبر، آدرس معتبر نیست** |
| | نماد یک تابع نیست. |
| 013 | **نقطه ورود وجود ندارد (هیچ تابع عمومی وجود ندارد)** |
| | فایل شامل تابع main یا هر تابع عمومی نیست. بنابراین فایل کامپایل شده نقطه شروعی برای اجرا ندارد. |
| 014 | **دستور نامعتبر؛ در switch نیست** |
| | دستورات case و default فقط داخل یک دستور switch معتبر هستند. |
| 015 | **"default" باید آخرین بند در دستور switch باشد** |
| | pawn نیاز دارد که بند default آخرین بند در یک دستور switch باشد. |
| 016 | **چندین default در "switch"** |
| | هر دستور switch فقط می‌تواند یک بند default داشته باشد. |
| 017 | **نماد تعریف نشده** _symbol_ |
| | نماد (متغیر، ثابت یا تابع) اعلام نشده است. |
| 018 | **داده‌های مقداردهی اولیه از اندازه اعلام شده بیشتر است** |
| | مقداردهی اولیه: 65 یک آرایه با اندازه صریح مقداردهی اولیه می‌شود، اما تعداد مقداردهنده‌های اولیه از تعداد عناصر مشخص شده بیشتر است. به عنوان مثال، در "arr[3]={1,2,3,4};" آرایه مشخص شده است که سه عنصر داشته باشد، اما چهار مقداردهنده اولیه وجود دارد. |
| 019 | **برچسب نیست:** _name_ |
| | یک دستور goto به نمادی شاخه می‌زند که یک برچسب نیست. |
| 020 | **نام نماد نامعتبر** |
| | یک نماد ممکن است با یک حرف، یک زیرخط یا یک علامت "at" ("@") شروع شود و ممکن است با یک سری از حروف، ارقام، کاراکترهای زیرخط و کاراکترهای "@" دنبال شود. |
| 021 | **نماد قبلاً تعریف شده است:** _identifier_ |
| | نماد قبلاً در سطح فعلی تعریف شده بود. |
| 022 | **باید lvalue (غیر ثابت) باشد** |
| | نمادی که تغییر داده می‌شود (افزایش، کاهش، اختصاص یک مقدار و غیره) باید یک متغیر قابل تغییر باشد (این نوع متغیر یک lvalue نامیده می‌شود). توابع، رشته‌های لیترال، آرایه‌ها و ثابت‌ها lvalue نیستند. متغیرهایی که با ویژگی "const" اعلام شده‌اند نیز lvalue نیستند. |
| 023 | **انتساب آرایه باید انتساب ساده باشد** |
| | هنگام اختصاص یک آرایه به آرایه دیگر، نمی‌توانید یک عملیات حسابی را با انتساب ترکیب کنید (به عنوان مثال، نمی‌توانید از عملگر "+=" استفاده کنید). |
| 024 | **"break" یا "continue" خارج از زمینه است** |
| | دستورات break و continue فقط در زمینه یک حلقه (یک دستور do، for یا while) معتبر هستند. برخلاف زبان‌های C/C⁺⁺ و Java، break از یک دستور switch خارج نمی‌شود. |
| 025 | **سرآیند تابع با نمونه اولیه متفاوت است** |
| | تعداد آرگومان‌های داده شده در اعلان قبلی تابع با تعداد آرگومان‌های داده شده در اعلان فعلی مطابقت ندارد. |
| 026 | **"#if..." مطابق وجود ندارد** |
| | دستورالعمل #else یا #endif مشاهده شد، اما هیچ دستورالعمل #if مطابقی یافت نشد. |
| 027 | **ثابت کاراکتری نامعتبر** |
| | یک دلیل احتمالی برای این خطا وقوع یک دنباله escape ناشناخته، مانند "\x" است. قرار دادن چندین کاراکتر بین نقل قول‌های تکی، مانند 'abc' نیز این پیام خطا را صادر می‌کند. دلیل سوم برای این خطا وضعیتی است که در آن یک ثابت کاراکتری مورد انتظار بود، اما هیچ (یا یک عبارت غیر کاراکتری) ارائه نشده است. |
| 028 | **زیرنویس نامعتبر (آرایه نیست یا زیرنویس‌های بیش از حد):** _identifier_ |
| | عملگرهای زیرنویس "[" و "]" فقط با آرایه‌ها معتبر هستند. تعداد جفت‌های براکت مربعی نمی‌تواند از تعداد ابعاد آرایه بیشتر باشد. |
| 029 | **عبارت نامعتبر، صفر فرض شده است** |
| | کامپایلر نتوانست عبارت را تفسیر کند. |
| 030 | **دستور مرکب در انتهای فایل بسته نشده است** |
| | پایان غیرمنتظره فایل رخ داده است. یک یا چند دستور مرکب هنوز ناتمام هستند (یعنی آکولاد بسته " " یافت نشده است). |
| 031 | **دستورالعمل ناشناخته** |
| | کاراکتر "#" اول در یک خط ظاهر می‌شود، اما هیچ دستورالعمل معتبری مشخص نشده است. |
| 032 | **شاخص آرایه خارج از محدوده است** |
| | شاخص آرایه بزرگتر از بالاترین ورودی معتبر آرایه است. |
| 033 | **آرایه باید شاخص‌گذاری شود** (**متغیر** _name_) |
| | یک آرایه به عنوان یک کل نمی‌تواند در یک عبارت استفاده شود؛ شما باید یک عنصر از آرایه را بین براکت‌های مربعی مشخص کنید. |
| 034 | **آرگومان مقدار پیش‌فرض ندارد** (**آرگومان** _index_) |
| | شما فقط می‌توانید از نگهدارنده آرگومان استفاده کنید هنگامی که تعریف تابع یک مقدار پیش‌فرض برای آرگومان مشخص می‌کند. |
| 035 | **عدم تطابق نوع آرگومان** (**آرگومان** _index_) |
| | آرگومانی که شما ارسال می‌کنید با آرگومانی که تابع انتظار دارد متفاوت است، و کامپایلر نمی‌تواند آرگومان ارسال شده را به نوع مورد نیاز تبدیل کند. به عنوان مثال، نمی‌توانید مقدار لیترال "1" را به عنوان آرگومان ارسال کنید هنگامی که تابع یک آرایه یا یک مرجع انتظار دارد. |
| 036 | **دستور خالی** |
| | خط شامل یک نقطه ویرگول است که قبل از آن عبارتی وجود ندارد. pawn یک نقطه ویرگول را به عنوان یک دستور خالی پشتیبانی نمی‌کند، به جای آن از یک بلوک مرکب خالی استفاده کنید. |
| 037 | **رشته نامعتبر (احتمالاً رشته بدون پایان)** |
| | یک رشته به خوبی شکل نگرفته است؛ به عنوان مثال، نقل قول نهایی که یک رشته را پایان می‌دهد وجود ندارد، یا نام فایل برای دستورالعمل #include در نقل قول دوگانه یا براکت‌های زاویه‌دار قرار نگرفته است. |
| 038 | **کاراکترهای اضافی در خط** |
| | کاراکترهای دنباله‌دار در خطی وجود داشت که شامل یک دستورالعمل بود (یک دستورالعمل با نماد # شروع می‌شود، به صفحه 117 مراجعه کنید). |
| 039 | **نماد ثابت اندازه ندارد** |
| | یک متغیر اندازه دارد (بر حسب تعداد سلول‌ها اندازه‌گیری می‌شود)، یک ثابت اندازه ندارد. یعنی، نمی‌توانید از یک ثابت (نمادین) با عملگر sizeof استفاده کنید، به عنوان مثال. |
| 040 | **برچسب "case" تکراری** (**مقدار** _value_) |
| | یک "برچسب case" قبلی در لیست دستور switch به همان مقدار ارزیابی می‌شود. |
| 041 | **سه نقطه نامعتبر، اندازه آرایه مشخص نیست** |
| | شما از نحوی مانند "arr[] = \{ 1, ... \};" استفاده کرده‌اید، که نامعتبر است، زیرا کامپایلر نمی‌تواند اندازه آرایه را از اعلان استنتاج کند. |
| 042 | **ترکیب نامعتبر مشخص‌کننده‌های کلاس** |
| | یک تابع یا متغیر هم به عنوان "public" و هم "native" مشخص شده است، که پشتیبانی نمی‌شود. ترکیب‌های دیگر نیز ممکن است پشتیبانی نشوند؛ به عنوان مثال، یک تابع نمی‌تواند هم "public" و هم "stock" باشد (یک متغیر ممکن است هم "public" و هم "stock" اعلام شود). |
| 043 | **ثابت کاراکتری از محدوده برای رشته فشرده فراتر می‌رود** |
| | معمولاً تلاشی برای ذخیره یک کاراکتر یونیکد در یک رشته فشرده که در آن یک کاراکتر فشرده 8 بیتی است. |
| 044 | **ترکیب پارامترهای نام‌گذاری شده و موقعیتی** |
| | شما باید یا از پارامترهای نام‌گذاری شده یا پارامترهای موقعیتی برای همه پارامترهای تابع استفاده کنید. |
| 045 | **آرگومان‌های تابع بیش از حد زیاد** |
| | حداکثر تعداد آرگومان‌های تابع در حال حاضر به 64 محدود شده است. |
| 046 | **اندازه آرایه ناشناخته** (**متغیر** _name_) |
| | برای انتساب آرایه، اندازه هر دو آرایه باید به صراحت تعریف شود، حتی اگر به عنوان آرگومان‌های تابع ارسال شوند. |
| 047 | **اندازه‌های آرایه مطابقت ندارند، یا آرایه مقصد خیلی کوچک است** |
| | برای انتساب آرایه، آرایه‌های سمت چپ و راست عملگر انتساب باید همان تعداد ابعاد را داشته باشند. علاوه بر این: |
| | - برای آرایه‌های چند بعدی، هر دو آرایه باید همان اندازه را داشته باشند؛ |
| | - برای آرایه‌های تکی با یک بعد، آرایه در سمت چپ عملگر انتساب باید اندازه‌ای برابر یا بزرگتر از آرایه سمت راست داشته باشد. |
| | هنگام ارسال آرایه‌ها به یک آرگومان تابع، این قوانین همچنین برای آرایه‌ای که به تابع ارسال می‌شود (در فراخوانی تابع) در مقابل آرایه اعلام شده در تعریف تابع اعمال می‌شود. |
| | هنگامی که یک تابع یک آرایه را برمی‌گرداند، تمام دستورات return باید یک آرایه با همان اندازه و ابعاد را مشخص کنند. |
| 048 | **ابعاد آرایه مطابقت ندارند** |
| | برای یک انتساب آرایه، ابعاد آرایه‌ها در هر دو طرف علامت "=" باید مطابقت داشته باشند؛ هنگام ارسال آرایه‌ها به یک آرگومان تابع، آرایه‌های ارسال شده به تابع (در فراخوانی تابع) باید با تعریف آرگومان‌های تابع مطابقت داشته باشند. |
| | هنگامی که یک تابع یک آرایه را برمی‌گرداند، تمام دستورات return باید یک آرایه با همان اندازه و ابعاد را مشخص کنند. |
| 049 | **ادامه خط نامعتبر** |
| | یک کاراکتر ادامه خط (یک بک‌اسلش در انتهای یک خط) در یک موقعیت نامعتبر قرار دارد، به عنوان مثال در انتهای یک فایل یا در یک توضیح تک خطی. |
| 050 | **محدوده نامعتبر** |
| | یک محدوده عددی با نحو "n1 .. n2"، که n1 و n2 ثابت‌های عددی هستند، نامعتبر است. یا یکی از مقادیر یک عدد معتبر نیست، یا n1 کوچکتر از n2 نیست. |
| 051 | **زیرنویس نامعتبر، از عملگرهای "[ ]" در ابعاد اصلی استفاده کنید** |
| | شما می‌توانید از عملگر "شاخص کاراکتر آرایه" (آکولادها: "\{ \}") فقط برای آخرین بعد استفاده کنید. برای ابعاد دیگر، باید از عملگر شاخص سلول (براکت‌های مربعی: "[ ]") استفاده کنید. |
| 052 | **آرایه‌های چند بعدی باید کاملاً مقداردهی اولیه شوند** |
| | اگر یک آرایه با بیش از یک بعد در اعلان خود مقداردهی اولیه شود، باید به همان تعداد بردارهای لیترال/زیرآرایه‌ها در سمت راست علامت مساوی ("=") وجود داشته باشد که برای بعد(های) اصلی آرایه مشخص شده است. |
| 053 | **تجاوز از حداکثر تعداد ابعاد** |
| | پیاده‌سازی فعلی کامپایلر pawn فقط از آرایه‌هایی با یک یا دو بعد پشتیبانی می‌کند. |
| 054 | **آکولاد بسته بدون تطابق** |
| | یک آکولاد بسته ("\}") بدون آکولاد باز ("\{") مطابق یافت شد. |
| 055 | **شروع بدنه تابع بدون سرآیند تابع** |
| | یک آکولاد باز ("\{") خارج از محدوده یک تابع یافت شد. این ممکن است توسط یک نقطه ویرگول در انتهای یک سرآیند تابع قبلی ایجاد شده باشد. |
| 056 | **متغیرهای محلی و آرگومان‌های تابع نمی‌توانند عمومی باشند** |
| | یک متغیر محلی یا یک آرگومان تابع با کاراکتر "@" شروع می‌شود، که نامعتبر است. |
| 057 | **عبارت ناتمام قبل از دستورالعمل کامپایلر** |
| | دستورالعمل‌های کامپایلر فقط می‌توانند بین دستورات ظاهر شوند، نه داخل یک دستور. این خطا معمولاً زمانی رخ می‌دهد که یک دستور عبارت روی چندین خط تقسیم شده است و یک دستورالعمل کامپایلر بین شروع و پایان عبارت ظاهر می‌شود. این پشتیبانی نمی‌شود. |
| 058 | **آرگومان تکراری؛ همان آرگومان دو بار ارسال شده است** |
| | در فراخوانی تابع، همان آرگومان دو بار ظاهر می‌شود، احتمالاً از طریق ترکیبی از پارامترهای نام‌گذاری شده و موقعیتی. |
| 059 | **آرگومان تابع نمی‌تواند مقدار پیش‌فرض داشته باشد** (**متغیر** _name_) |
| | تمام آرگومان‌های توابع عمومی باید به صراحت ارسال شوند. توابع عمومی معمولاً از برنامه میزبان فراخوانی می‌شوند، که هیچ اطلاعی از مقادیر پیش‌فرض پارامتر ندارد. آرگومان‌های عملگرهای تعریف شده توسط کاربر از عبارت استنباط می‌شوند و نمی‌توانند از مقدار پیش‌فرض یک آرگومان استنتاج شوند. |
| 060 | **چندین دستورالعمل "#else" بین "#if . . . #endif** |
| | دو یا چند دستورالعمل #else در بدنه بین #if و #endif مطابق ظاهر می‌شوند. |
| 061 | **دستورالعمل "#elseif" پس از یک دستورالعمل "#else" قرار دارد** |
| | تمام دستورالعمل‌های #elseif باید قبل از دستورالعمل #else ظاهر شوند. این خطا همچنین ممکن است نشان دهد که یک دستورالعمل #endif برای یک سطح بالاتر از دست رفته است. |
| 062 | **تعداد عملوندها با عملگر مطابقت ندارد** |
| | هنگام بازتعریف یک عملگر، تعداد عملوندهایی که عملگر دارد (1 برای عملگرهای یکانی و 2 برای عملگرهای دوتایی) باید برابر با تعداد آرگومان‌های تابع عملگر باشد. |
| 063 | **عملگر نیاز دارد که نتیجه تابع یک تگ "bool" داشته باشد** |
| | عملگرهای منطقی و رابطه‌ای به عنوان داشتن نتیجه‌ای که یا درست (1) یا نادرست (0) است و دارای یک تگ "bool" است، تعریف شده‌اند. یک عملگر تعریف شده توسط کاربر باید به این تعریف پایبند باشد. |
| 064 | **نمی‌توان عملگرهای از پیش تعریف شده را تغییر داد** |
| | نمی‌توان عملگرهایی را تعریف کرد که روی مقادیر بدون تگ کار کنند، به عنوان مثال، زیرا pawn قبلاً این عملیات را تعریف کرده است. |
| 065 | **آرگومان تابع فقط می‌تواند یک تگ واحد داشته باشد** (**آرگومان** _number_) |
| | در یک عملگر تعریف شده توسط کاربر، یک آرگومان تابع نمی‌تواند چندین تگ داشته باشد. |
| 066 | **آرگومان تابع نمی‌تواند یک آرگومان مرجع یا یک آرایه باشد** (**آرگومان** _number_) |
| | در یک عملگر تعریف شده توسط کاربر، تمام آرگومان‌ها باید سلول‌هایی (غیر آرایه) باشند که "با مقدار" ارسال می‌شوند. |
| 067 | **متغیر نمی‌تواند هم یک مرجع و هم یک آرایه باشد** (**متغیر** _name_) |
| | یک آرگومان تابع ممکن است به عنوان یک "مرجع" یا به عنوان یک آرایه مشخص شود، اما نه به عنوان هر دو. |
| 068 | **دقت عدد گویا نامعتبر در #pragma** |
| | دقت منفی یا خیلی بالا بود. برای اعداد گویای نقطه شناور، مشخصات دقت باید حذف شود. |
| 069 | **فرمت عدد گویا قبلاً تعریف شده است** |
| | این #pragma با یک #pragma قبلی که یک فرمت متفاوت را مشخص کرده بود، در تضاد است. |
| 070 | **پشتیبانی از اعداد گویا فعال نشده بود** |
| | یک عدد گویای لیترال مشاهده شد، اما فرمت برای اعداد گویا مشخص نشده بود. |
| 071 | **عملگر تعریف شده توسط کاربر باید قبل از استفاده اعلام شود** (**تابع** _name_) |
| | مانند یک متغیر، یک عملگر تعریف شده توسط کاربر باید قبل از اولین استفاده آن اعلام شود. این پیام نشان می‌دهد که قبل از اعلام عملگر تعریف شده توسط کاربر، یک نمونه که در آن عملگر روی عملوندهایی با همان تگ‌ها استفاده شده بود، رخ داده است. این ممکن است یا نشان دهد که برنامه سعی می‌کند از عملگر پیش‌فرض و یک عملگر تعریف شده توسط کاربر به صورت ترکیبی استفاده کند (که پشتیبانی نمی‌شود)، یا اینکه عملگر تعریف شده توسط کاربر باید "به صورت رو به جلو اعلام شود". |
| 072 | **عملگر "sizeof " روی نمادهای "function" نامعتبر است** |
| | شما از چیزی مانند "sizeof MyCounter" استفاده کرده‌اید که در آن نماد "MyCounter" یک متغیر نیست، بلکه یک تابع است. شما نمی‌توانید اندازه یک تابع را درخواست کنید. |
| 073 | **آرگومان تابع باید یک آرایه باشد** (**آرگومان** _name_) |
| | آرگومان تابع یک ثابت یا یک متغیر ساده است، اما تابع نیاز دارد که شما یک آرایه ارسال کنید. |
| 074 | **الگوی #define باید با یک کاراکتر الفبایی شروع شود** |
| | هر الگو برای دستورالعمل #define باید با یک حرف، یک زیرخط ("\_") یا یک کاراکتر "@" شروع شود. الگو اولین کلمه‌ای است که پس از کلیدواژه #define می‌آید. |
| 075 | **خط ورودی خیلی طولانی است (پس از جایگزینی‌ها)** |
| | یا فایل منبع شامل یک خط بسیار طولانی است، یا جایگزینی‌های متن باعث می‌شوند خطی که در ابتدا طول قابل قبولی داشت، از محدوده خود فراتر رود. این ممکن است توسط یک جایگزینی متن که باعث جایگزینی بازگشتی می‌شود ایجاد شود (الگو با بخشی از متن جایگزین مطابقت می‌کند، به طوری که این بخش از متن جایگزین نیز مطابقت داده می‌شود و جایگزین می‌شود، و غیره). |
| 076 | **خطای نحوی در عبارت، یا** _فراخوانی تابع_ **نامعتبر** |
| | عبارت دستور به عنوان یک دستور معتبر شناخته نشد (بنابراین یک "خطای نحوی" است). از بخشی از رشته که تجزیه شد، به نظر می‌رسد خط منبع شامل یک فراخوانی تابع در نحو "فراخوانی روال" است (حذف پرانتزها)، اما نتیجه تابع استفاده می‌شود —به یک متغیر اختصاص داده می‌شود، به عنوان یک پارامتر ارسال می‌شود، در یک عبارت استفاده می‌شود. . . |
| 077 | **کدگذاری UTF-8 نادرست، یا فایل خراب: filename** |
| | فایل با یک امضای UTF-8 شروع می‌شود، اما شامل کدگذاری‌هایی است که UTF-8 معتبر نیستند. اگر فایل منبع توسط یک ویرایشگر یا مبدل که از UTF-8 پشتیبانی می‌کند ایجاد شده باشد، پشتیبانی UTF-8 مطابق با استاندارد نیست. |
| 078 | **تابع هم از "return" و هم از "return ¡value¿" استفاده می‌کند** |
| | تابع هم با و هم بدون یک مقدار بازگشتی برمی‌گردد. تابع باید در همیشه برگرداندن با یک نتیجه تابع، یا هرگز برنگرداندن یک نتیجه تابع، سازگار باشد. |
| 079 | **انواع بازگشتی ناسازگار (آرایه و غیر آرایه)** |
| | تابع هم مقادیر و هم آرایه‌ها را برمی‌گرداند، که مجاز نیست. اگر یک تابع یک آرایه را برمی‌گرداند، تمام دستورات return باید یک آرایه (با همان اندازه و ابعاد) را مشخص کنند. |
| 080 | **نماد ناشناخته، یا نماد ثابت نیست** (**نماد** _name_) |
| | جایی که یک مقدار ثابت مورد انتظار بود، یک نماد ناشناخته یا یک نماد غیر ثابت (متغیر) یافت شد. |
| 081 | **نمی‌توان یک تگ را به عنوان یک مقدار پیش‌فرض برای یک پارامتر آرایه شاخص‌دار گرفت** (**نماد** _name_) |
| | عملگر tagof روی یک پارامتر آرایه استفاده شده است که آرایه همچنین یک شاخص داشت. این پشتیبانی نمی‌شود. |
| 082 | **عملگرهای تعریف شده توسط کاربر و توابع بومی نمی‌توانند حالت داشته باشند** |
| | فقط توابع استاندارد و عمومی می‌توانند حالت داشته باشند. |
| 083 | **یک تابع یا متغیر فقط می‌تواند به یک اتوماتون واحد تعلق داشته باشد** (**نماد** _name_) |
| | چندین اتوماتون در اعلان حالت برای تابع یا متغیر مشخص شده وجود دارد، که پشتیبانی نمی‌شود. در مورد یک تابع: تمام نمونه‌های تابع باید به همان اتوماتون تعلق داشته باشند. در مورد یک متغیر: مجاز است چندین متغیر با همان نام داشته باشید که به اتوماتون‌های مختلف تعلق دارند، اما فقط در اعلان‌های جداگانه —اینها متغیرهای متمایزی هستند. |
| 084 | **تعارض حالت: یکی از حالت‌ها قبلاً به پیاده‌سازی دیگری اختصاص داده شده است** (**نماد** _name_) |
| | حالت مشخص شده در مشخص‌کننده حالت دو پیاده‌سازی از همان تابع ظاهر می‌شود. |
| 085 | **هیچ حالتی برای نماد name تعریف نشده است** |
| | هنگامی که این خطا در یک تابع رخ می‌دهد، این تابع یک پیاده‌سازی پشتیبان دارد، اما حالت‌های دیگری ندارد. اگر خطا به یک متغیر اشاره دارد، این متغیر لیستی از حالت‌ها بین کاراکترهای < و > ندارد. به جای آن از یک تابع یا متغیر بدون حالت استفاده کنید. |
| 086 | **نام اتوماتون ناشناخته** |
| | دستور "state" به یک اتوماتون ناشناخته اشاره دارد. |
| 087 | **نام حالت ناشناخته برای اتوماتون name** |
| | دستور "state" به یک حالت ناشناخته (برای اتوماتون مشخص شده) اشاره دارد. |
| 088 | **متغیرهای عمومی و متغیرهای محلی نمی‌توانند حالت داشته باشند** (**نماد** _name_) |
| | فقط متغیرهای استاندارد (جهانی) می‌توانند در انتهای یک اعلان لیستی از حالت‌ها (و یک اتوماتون) داشته باشند. |
| 089 | **متغیرهای حالت نمی‌توانند مقداردهی اولیه شوند** (**نماد** _name_) |
| | متغیرهایی با یک لیست حالت پیوست شده نمی‌توانند مقداردهنده‌های اولیه داشته باشند. متغیرهای حالت باید همیشه به صراحت مقداردهی اولیه شوند، زیرا مقدار اولیه آنها نامشخص است. |
| 090 | **توابع عمومی نمی‌توانند آرایه برگردانند** (**نماد** _name_) |
| | یک تابع عمومی نمی‌تواند یک آرایه را برگرداند. برگرداندن آرایه‌ها فقط برای توابع عادی مجاز است. |

### • خطاهای مهلک

| شماره | توضیحات |
| ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 100 | **نمی‌توان از فایل خواند:** _filename_ |
| | کامپایلر نمی‌تواند فایل مشخص شده را پیدا کند یا به آن دسترسی ندارد. |
| 101 | **نمی‌توان در فایل نوشت:** _filename_ |
| | کامپایلر نمی‌تواند در فایل خروجی مشخص شده بنویسد، احتمالاً به دلیل فضای دیسک ناکافی یا حقوق دسترسی محدود (فایل ممکن است فقط خواندنی باشد، به عنوان مثال). |
| 102 | **سرریز جدول:** _table name_ |
| | یک جدول داخلی در تجزیه‌کننده pawn برای نگهداری داده‌های مورد نیاز خیلی کوچک است. برخی جداول به صورت پویا قابل رشد هستند، که به این معنی است که حافظه ناکافی برای تغییر اندازه جدول وجود داشت. "نام جدول" یکی از موارد زیر است: |
| | "بافر مرحله‌بندی": بافر مرحله‌بندی کد تولید شده برای یک عبارت را قبل از ارسال آن به بهینه‌ساز روزنه نگه می‌دارد. بافر مرحله‌بندی به صورت پویا رشد می‌کند، بنابراین یک سرریز بافر مرحله‌بندی اساساً یک خطای "حافظه ناکافی" است. |
| | "جدول حلقه": جدول حلقه یک پشته است که با دستورات do، for و while تو در تو استفاده می‌شود. جدول اجازه می‌دهد این دستورات تا 24 سطح تو در تو شوند. |
| | "جدول لیترال": این جدول ثابت‌های لیترال (اعداد، رشته‌ها) را که در عبارات و به عنوان مقداردهنده‌های اولیه برای آرایه‌ها استفاده می‌شوند، نگه می‌دارد. جدول لیترال به صورت پویا رشد می‌کند، بنابراین یک سرریز جدول لیترال اساساً یک خطای "حافظه ناکافی" است. |
| | "پشته کامپایلر": کامپایلر از یک پشته برای ذخیره اطلاعات موقت که هنگام تجزیه به آن نیاز دارد استفاده می‌کند. یک سرریز این پشته احتمالاً توسط شمول فایل عمیقاً تو در تو (یا بازگشتی) ایجاد می‌شود. پشته کامپایلر به صورت پویا رشد می‌کند، بنابراین یک سرریز پشته کامپایلر اساساً یک خطای "حافظه ناکافی" است. |
| | "جدول گزینه": در صورتی که گزینه‌های بیشتری در خط فرمان یا در فایل پاسخ وجود داشته باشد که کامپایلر نمی‌تواند با آن کنار بیاید. |
| 103 | **حافظه ناکافی** |
| | خطای عمومی "حافظه ناکافی". |
| 104 | **نماد دستورالعمل اسمبلر نامعتبر** |
| | یک کد عملیاتی نامعتبر در یک دستورالعمل #emit. |
| 105 | **سرریز عددی، فراتر از ظرفیت** |
| | یک ثابت عددی، به ویژه یک بعد از یک آرایه، برای کامپایلر خیلی بزرگ است. به عنوان مثال، هنگامی که به عنوان یک برنامه 16 بیتی کامپایل می‌شود، کامپایلر نمی‌تواند آرایه‌هایی با بیش از 32767 عنصر را مدیریت کند. |
| 106 | **اسکریپت کامپایل شده از حداکثر اندازه حافظه فراتر می‌رود** (_number_ **بایت**) |
| | اندازه حافظه برای ماشین انتزاعی که برای اجرای اسکریپت مورد نیاز است از مقدار تنظیم شده با #pragma amxlimit فراتر می‌رود. این بدان معناست که اسکریپت برای پشتیبانی توسط میزبان خیلی بزرگ است. ممکن است سعی کنید نیازهای حافظه اسکریپت را با: |
| | - تنظیم یک منطقه پشته/هیپ کوچکتر —به #pragma dynamic در صفحه 121 مراجعه کنید؛ |
| | - استفاده از رشته‌های فشرده به جای رشته‌های غیر فشرده —به صفحات 99 و 137 مراجعه کنید؛ |
| | - قرار دادن کد تکراری در توابع جداگانه؛ |
| | - قرار دادن داده‌های تکراری (رشته‌ها) در متغیرهای جهانی؛ |
| | - تلاش برای یافتن الگوریتم‌های فشرده‌تر برای انجام همان کار. |
| 107 | **پیام‌های خطا/هشدار بیش از حد در یک خط** |
| | یک خط واحد که باعث چندین پیام خطا/هشدار می‌شود اغلب نشانه‌ای است که تجزیه‌کننده pawn قادر به "بازیابی" از یک خطای قبلی نیست. در این وضعیت، تجزیه‌کننده احتمالاً نمی‌تواند هیچ معنایی از کد منبعی که دنبال می‌کند بسازد —و فقط پیام‌های خطای نامناسب (بیشتری) تولید می‌کند. بنابراین، کامپایل متوقف می‌شود. |
| 108 | **فایل نگاشت کدپیج یافت نشد** |
| | فایل برای ترجمه کدپیج که با گزینه -c کامپایلر یا دستورالعمل #pragma codepage مشخص شده بود، نمی‌توانست بارگذاری شود. |
| 109 | **مسیر نامعتبر:** _path name_ |
| | یک مسیر، به عنوان مثال برای فایل‌های شامل یا فایل‌های کدپیج، نامعتبر است. |
| 110 | **تأیید شکست خورد:** _expression_ |
| | تأیید زمان کامپایل شکست خورد. |
| 111 | **خطای کاربر:** _message_ |
| | تجزیه‌کننده روی یک دستورالعمل #error افتاد. |

### • هشدارها

| شماره | توضیحات |
| ------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 200 | **نماد به** _number_ **کاراکتر کوتاه می‌شود** |
| | نماد طولانی‌تر از حداکثر طول نماد است. حداکثر طول یک نماد بستگی به این دارد که آیا نماد بومی، عمومی یا هیچ کدام است. کوتاه کردن ممکن است باعث شود نام‌های نماد مختلف یکسان شوند، که ممکن است باعث خطای 021 یا هشدار 219 شود. |
| 201 | **بازتعریف ثابت/ماکرو** (**نماد** _name_) |
| | نماد قبلاً با یک مقدار متفاوت تعریف شده بود، یا ماکروی جایگزینی متن که با پیشوند نام شروع می‌شود با یک متن جایگزینی متفاوت بازتعریف شده بود. |
| 202 | **تعداد آرگومان‌ها با تعریف مطابقت ندارد** |
| | در یک فراخوانی تابع، تعداد آرگومان‌های ارسال شده به تابع (آرگومان‌های واقعی) با تعداد آرگومان‌های رسمی اعلام شده در سرآیند تابع متفاوت است. برای اعلام توابع با لیست‌های آرگومان متغیر، از یک سه نقطه (...) پشت آخرین آرگومان شناخته شده در سرآیند تابع استفاده کنید؛ به عنوان مثال: print(formatstring,...); (به صفحه 80 مراجعه کنید). |
| 203 | **نماد هرگز استفاده نمی‌شود:** _identifier_ |
| | یک نماد تعریف شده است اما هرگز استفاده نمی‌شود. توابع عمومی از بررسی استفاده نماد مستثنی هستند (زیرا ممکن است از خارج فراخوانی شوند). |
| 204 | **به نماد مقداری اختصاص داده می‌شود که هرگز استفاده نمی‌شود:** _identifier_ |
| | یک مقدار به یک نماد اختصاص داده می‌شود، اما محتوای نماد هرگز دسترسی پیدا نمی‌کند. |
| 205 | **کد زائد: عبارت ثابت صفر است** |
| | جایی که یک عبارت شرطی مورد انتظار بود، یک عبارت ثابت با مقدار صفر یافت شد، مثلاً "while (0)" یا "if (0)". |
| | کد شرطی زیر آزمون هرگز اجرا نمی‌شود، و بنابراین زائد است. |
| 206 | **آزمون زائد: عبارت ثابت غیر صفر است** |
| | جایی که یک عبارت شرطی مورد انتظار بود، یک عبارت ثابت با یک مقدار غیر صفر یافت شد، مثلاً if (1). آزمون زائد است، زیرا کد شرطی همیشه اجرا می‌شود. |
| 207 | **"#pragma" ناشناخته** |
| | کامپایلر pragma را نادیده می‌گیرد. دستورالعمل‌های #pragma ممکن است بین کامپایلرهای فروشندگان مختلف و بین نسخه‌های مختلف یک کامپایلر از همان نسخه تغییر کنند. |
| 208 | **تابع با نتیجه تگ قبل از تعریف استفاده شده است، مجبور به تجزیه مجدد** |
| | هنگامی که یک تابع قبل از اعلام شدن "استفاده" (فراخوانی) می‌شود، و آن تابع مقداری با یک نام تگ برمی‌گرداند، پارسر باید یک گذر اضافی روی کد منبع انجام دهد، زیرا وجود نام تگ ممکن است تفسیر عملگرها را تغییر دهد (در حضور عملگرهای تعریف شده توسط کاربر). شما می‌توانید فرآیند تجزیه/کامپایل را با اعلام توابع مربوطه قبل از استفاده از آنها سرعت بخشید. |
| 209 | **تابع باید یک مقدار را برگرداند** |
| | تابع یک دستور return ندارد، یا پشت دستور return یک عبارت ندارد، اما نتیجه تابع در یک عبارت استفاده می‌شود. |
| 210 | **استفاده احتمالی از نماد قبل از مقداردهی اولیه:** _identifier_ |
| | به نظر می‌رسد یک متغیر محلی (مقداردهی اولیه نشده) قبل از اینکه مقداری به آن اختصاص داده شود، خوانده می‌شود. کامپایلر نمی‌تواند ترتیب واقعی خواندن از و ذخیره در متغیرها را تعیین کند و فرض خود را بر اساس ترتیب ظاهر فیزیکی دستورات و عبارات در فایل منبع قرار می‌دهد. |
| 211 | **انتساب احتمالاً ناخواسته** |
| | جایی که یک عبارت شرطی مورد انتظار بود، عملگر انتساب (=) به جای عملگر برابری (==) یافت شد. از آنجا که این یک اشتباه رایج است، کامپایلر یک هشدار صادر می‌کند. برای جلوگیری از این پیام، پرانتزهایی را دور عبارت قرار دهید، مثلاً if ( (a=2) ). |
| 212 | **عملیات بیتی احتمالاً ناخواسته** |
| | جایی که یک عبارت شرطی مورد انتظار بود، یک عملگر بیتی (& یا \|) به جای یک عملگر بولی (&& یا \|\|) یافت شد. در مواردی که یک عملیات بیتی بعید به نظر می‌رسد، کامپایلر این هشدار را صادر می‌کند. برای جلوگیری از این پیام، پرانتزهایی را دور عبارت قرار دهید. |
| 213 | **عدم تطابق تگ** |
| | یک عدم تطابق تگ زمانی رخ می‌دهد که: |
| | - به یک متغیر تگ‌دار مقداری اختصاص داده می‌شود که بدون تگ است یا تگ متفاوتی دارد |
| | - عبارات در هر دو طرف یک عملگر دوتایی تگ‌های متفاوتی دارند |
| | - در یک فراخوانی تابع، ارسال یک آرگومان که بدون تگ است یا تگی متفاوت از آنچه آرگومان تابع با آن تعریف شده است، دارد |
| | - شاخص‌گذاری یک آرایه که نیاز به یک شاخص تگ‌دار دارد با هیچ تگ یا یک نام تگ اشتباه |
| 214 | **احتمالاً یک آرگومان آرایه "const" مورد نظر بوده است:** _identifier_ |
| | آرایه‌ها همیشه با مرجع ارسال می‌شوند. اگر یک تابع آرگومان آرایه را تغییر نمی‌دهد، با این حال، کامپایلر گاهی اوقات می‌تواند کد فشرده‌تر و سریع‌تری تولید کند اگر آرگومان آرایه به طور خاص به عنوان "const" علامت‌گذاری شود. |
| 215 | **عبارت هیچ تأثیری ندارد** |
| | نتیجه عبارت ظاهراً در یک متغیر ذخیره نمی‌شود یا در یک آزمون استفاده نمی‌شود. بنابراین عبارت یا دستور عبارت زائد است. |
| 216 | **توضیح تو در تو** |
| | PAWN از توضیحات تو در تو پشتیبانی نمی‌کند. |
| 217 | **تورفتگی آزاد** |
| | دستورات در همان سطح منطقی در همان ستون شروع نمی‌شوند؛ یعنی، تورفتگی‌های دستورات متفاوت هستند. اگرچه pawn یک زبان با فرمت آزاد است، تورفتگی آزاد اغلب یک خطای منطقی در جریان کنترل را پنهان می‌کند. |
| | کامپایلر همچنین ممکن است تورفتگی آزاد را به اشتباه فرض کند اگر اندازه تب که با آن کد منبع را تورفته کرده‌اید با اندازه فرض شده متفاوت باشد، به #pragma tabsize در صفحه 122 یا گزینه کامپایلر -t در صفحه 169 مراجعه کنید. |
| 218 | **نمونه اولیه‌های سبک قدیمی با نقطه ویرگول اختیاری استفاده شده‌اند** |
| | هنگام استفاده از "نقطه ویرگول‌های اختیاری"، ترجیح داده می‌شود که توابع رو به جلو را به صراحت با کلیدواژه forward اعلام کنید تا استفاده از نقطه ویرگول پایانی. |
| 219 | **متغیر محلی identifier یک نماد را در یک سطح قبلی سایه می‌اندازد** |
| | یک متغیر محلی همان نامی را دارد که یک متغیر جهانی، یک تابع، یک آرگومان تابع، یا یک متغیر محلی در یک سطح اولویت پایین‌تر دارد. این "سایه انداختن" نامیده می‌شود، زیرا متغیر محلی جدید تابع یا متغیر تعریف شده قبلی را غیرقابل دسترس می‌کند. |
| | توجه: اگر پیام‌های خطای بیشتری در ادامه اسکریپت درباره متغیرهای گم شده (با همین نام‌ها) یا مشکلات سطح آکولاد وجود دارد، ممکن است هشدارهای سایه انداختن به دلیل این خطاهای نحوی و معنایی باشند. ابتدا خطاها را برطرف کنید قبل از اینکه به هشدارهای سایه انداختن نگاه کنید. |
| 220 | **عبارت با لغو تگ باید بین پرانتزها ظاهر شود** |
| | در یک دستور case و در عبارات در عملگر شرطی (" ? : ")، هر عبارتی که یک لغو تگ دارد باید بین پرانتزها قرار گیرد، تا از تفسیر اشتباه دو نقطه به عنوان یک جداکننده دستور case یا به عنوان بخشی از عملگر شرطی جلوگیری شود. |
| 221 | **نام برچسب identifier نام تگ را سایه می‌اندازد** |
| | یک برچسب کد (برای دستور goto) همان نامی را دارد که یک تگ تعریف شده قبلی. این ممکن است یک لغو تگ اشتباه را نشان دهد؛ یک مورد معمول تلاش برای اعمال یک لغو تگ روی متغیر در سمت چپ عملگر = در یک دستور انتساب است. |
| 222 | **تعداد ارقام از دقت عدد گویا فراتر می‌رود** |
| | یک عدد گویای لیترال دارای دهدهی‌های بیشتری در بخش کسری خود نسبت به دقتی که یک عدد گویا پشتیبانی می‌کند، است. دهدهی‌های باقیمانده نادیده گرفته می‌شوند. |
| 223 | **"sizeof " زائد: اندازه آرگومان همیشه 1 است** (**نماد** _name_) |
| | یک آرگومان تابع به عنوان مقدار پیش‌فرض خود اندازه آرگومان دیگری از همان تابع را دارد. مقدار پیش‌فرض "sizeof" فقط زمانی مفید است که اندازه آرگومان مورد اشاره در اعلان تابع مشخص نشده باشد؛ یعنی، اگر آرگومان مورد اشاره یک آرایه باشد. |
| 224 | **اندازه آرایه نامشخص در عبارت "sizeof "** (**نماد** _name_) |
| | عملوند عملگر sizeof یک آرایه با اندازه نامشخص است. یعنی، اندازه متغیر نمی‌تواند در زمان کامپایل تعیین شود. اگر در یک دستور "if" استفاده می‌شود، یک بخش کامپایل شده شرطی را در نظر بگیرید، جایگزینی if با #if. |
| 225 | **کد غیرقابل دسترس** |
| | کد مشخص شده هرگز اجرا نخواهد شد، زیرا یک دستورالعمل قبل از (بالای) آن باعث پرش به خارج از تابع، خارج از یک حلقه یا جای دیگر می‌شود. به دنبال دستورات return، break، continue و goto بالای خط مشخص شده باشید. |
| 226 | **یک متغیر به خودش اختصاص داده می‌شود** (**نماد** _name_) |
| | یک دستور مانند "x = x" در کد وجود دارد. پارسر پس از انجام هرگونه جایگزینی متن و ثابت، برای خود-انتساب‌ها بررسی می‌کند، بنابراین سمت چپ و راست یک انتساب ممکن است در نگاه اول متفاوت به نظر برسند. به عنوان مثال، اگر نماد "TWO" یک ثابت با مقدار 2 باشد، آنگاه "var[TWO] = var[2]" نیز یک خود-انتساب است. |
| | خود-انتساب‌ها، البته، زائد هستند، و ممکن است یک خطا را پنهان کنند (انتساب به متغیر اشتباه، خطا در اعلام ثابت‌ها). |
| | توجه داشته باشید که پارسر pawn محدود به انجام "بررسی‌های استاتیک" است. در این مورد به این معنی است که فقط می‌تواند انتساب‌های آرایه را برای خود-انتساب با شاخص‌های آرایه ثابت مقایسه کند. |
| 227 | **مقداردهنده‌های اولیه بیشتر از فیلدهای enum** |
| | یک آرایه که اندازه آن با یک نماد enum اعلام شده است شامل مقادیر/فیلدهای بیشتری به عنوان مقداردهنده‌های اولیه نسبت به آنچه شمارش تعریف می‌کند، است. |
| 228 | **طول مقداردهنده اولیه از اندازه فیلد enum فراتر می‌رود** |
| | یک آرایه که اندازه آن با یک نماد enum اعلام شده است، و فیلد شمارش مربوطه یک اندازه دارد. مقداردهنده اولیه در آرایه شامل مقادیر بیشتری نسبت به آنچه اندازه فیلد شمارش اجازه می‌دهد، است. |
| 229 | **عدم تطابق تگ شاخص** (**نماد** _name_) |
| | هنگام شاخص‌گذاری یک آرایه، عبارت استفاده شده به عنوان شاخص یک تگ متفاوت از آنچه در اعلان آرایه است، دارد. برای توضیح و مثال‌ها به صفحات 29 و 68 مراجعه کنید. |
| 230 | **هیچ پیاده‌سازی برای حالت** _name_ **در تابع** _name_ **وجود ندارد، بدون پشتیبان** |
| | یک تابع فاقد پیاده‌سازی برای حالت مشخص شده است. کامپایلر نمی‌تواند (به صورت استاتیک) بررسی کند که آیا تابع در آن حالت فراخوانی خواهد شد یا خیر، و بنابراین این هشدار را صادر می‌کند. هنگامی که تابع برای حالتی که هیچ پیاده‌سازی برای آن وجود ندارد فراخوانی شود، ماشین انتزاعی با یک خطای زمان اجرا متوقف می‌شود. |
| | برای اطلاع از نحوه مشخص کردن یک تابع پشتیبان به صفحه 83 و برای توضیح و مثال به صفحه 44 مراجعه کنید. |
| 231 | **مشخصات حالت در اعلان رو به جلو نادیده گرفته می‌شود** |
| | یک مشخصات حالت در اعلان‌های رو به جلو زائد است. امضای تابع باید برای همه حالت‌ها یکسان باشد. فقط پیاده‌سازی‌های تابع مختص حالت هستند. |
| 232 | **سرریز بافر فشرده‌سازی** |
| | کدگذاری فشرده ممکن است در برخی موارد خاص منجر به فایل‌هایی شود که در واقع بزرگتر از کدگذاری غیر فشرده باشند. ماشین انتزاعی نمی‌تواند این را مدیریت کند، زیرا P-code را "در محل" باز می‌کند. هنگامی که کامپایلر این وضعیت را تشخیص می‌دهد، فایل را با کدگذاری فشرده خاموش دوباره می‌سازد. برای جلوگیری از این هشدار، ساخت فایل را با کدگذاری ساده ("غیر فشرده") اجبار کنید —به صفحه 120 مراجعه کنید. |
| 233 | **نام متغیر حالت یک متغیر جهانی را سایه می‌اندازد** |
| | متغیر حالت همان نامی را دارد که یک متغیر جهانی (بدون مشخص‌کننده‌های حالت). این بدان معناست که متغیر جهانی برای یک تابع با یکی از همان حالت‌های متغیر غیرقابل دسترس است. |
| 234 | **تابع منسوخ شده است** (**نماد** _name_) |
| | اسکریپت از تابعی استفاده می‌کند که به عنوان "منسوخ شده" علامت‌گذاری شده است. برنامه میزبان می‌تواند توابع (بومی) را به عنوان منسوخ شده علامت‌گذاری کند هنگامی که جایگزین‌های بهتری برای تابع در دسترس باشند یا اگر تابع ممکن است در نسخه‌های آینده برنامه میزبان پشتیبانی نشود. |
| 235 | **فراخوانی به تابع عمومی اعلام نشده** (**نماد** _name_) |
| | اسکریپت یک تابع عمومی را تعریف می‌کند، اما هیچ اعلان رو به جلو از این تابع وجود ندارد. احتمالاً نام تابع به اشتباه نوشته شده است. الزام به اعلان‌های رو به جلو توابع عمومی در برابر یک خطای رایج محافظت می‌کند. |
| 236 | **پارامتر ناشناخته در جایگزینی (الگوی #define نادرست)** |
| | یک الگوی #define شامل یک پارامتر در جایگزینی (مثلاً "%1") است، اما یکی در الگوی تطبیق. برای نحو پیش‌پردازنده به صفحه 93 مراجعه کنید. |

---

`دام‌ها: 134`

`دستور مرکب: 112`

`دستور مرکب: 112`

`اعلان رو به جلو: 82`

`نحو نام نماد: 97`

`دنباله escape: 99`

`بلوک مرکب خالی: 112`

`توضیح تک خطی: 97`

`پارامترهای نام‌گذاری شده در مقابل موقعیتی: 74`

`#pragma rational: 121`

`اعلان رو به جلو: 82`

`مشخص‌کننده‌های حالت: 83`

`پشتیبان: 83`

`همچنین به #pragma مراجعه کنید`

`amxlimit در صفحه 119`

`#pragma codepage: 120`

`دستورالعمل #assert: 117`

`دستورالعمل #error: 117`

`عملگرهای تعریف شده توسط کاربر: 86`

`اعلان رو به جلو: 82`

`تگ‌ها در صفحه 68 بحث شده‌اند`

`#if . . . #else . . . #endif: 117`

`مشخص‌کننده‌های حالت: 83`

---

## کامپایلر

---

بسیاری از برنامه‌هایی که زبان اسکریپت‌نویسی PAWN را جاسازی می‌کنند از کامپایلر
مستقلی که با مجموعه ابزار PAWN همراه است استفاده می‌کنند. کامپایلر PAWN یک
ابزار خط فرمان است، به این معنی که باید آن را از یک "پنجره کنسول"،
یک ترمینال/شل، یا یک "جعبه DOS" (بسته به اینکه سیستم عامل شما چه می‌نامد) اجرا کنید.

### • استفاده

با فرض اینکه کامپایلر خط فرمان PAWN "_pawncc_" (Unix/
Linux) یا "_pawncc.exe_" (DOS/Windows) نامیده می‌شود، نحو خط فرمان به شرح زیر است:

    pawncc \<filename\> [more filenames...] [options]

نام فایل ورودی هر نام فایل قانونی است. اگر هیچ پسوندی داده نشود، "_.pawn_"
یا ".p" فرض می‌شود. کامپایلر یک فایل خروجی با، به طور پیش‌فرض، همان
نام فایل ورودی و پسوند ".amx" ایجاد می‌کند.

پس از تغییر به دایرکتوری با برنامه‌های نمونه، دستور:

    pawncc hello

باید اولین مثال "hello world" (صفحه 5) را کامپایل کند. باید، زیرا
دستور بیان می‌کند که:

- سیستم عامل می‌تواند برنامه "_pawncc_" را پیدا کند —ممکن است نیاز داشته باشید آن را به مسیر جستجو اضافه کنید؛

- کامپایلر PAWN قادر به تعیین موقعیت خود در سیستم فایل است تا بتواند فایل‌های شامل را پیدا کند —چند سیستم عامل از این پشتیبانی نمی‌کنند و نیاز دارند که از گزینه -i استفاده کنید (به زیر مراجعه کنید).

### • فایل ورودی

فایل ورودی برای کامپایلر PAWN، فایل "کد منبع" برای
اسکریپت/برنامه، باید یک فایل متنی ساده باشد. تمام کلمات رزرو شده و تمام نام‌های نماد
(نام‌های متغیرها، توابع، ثابت‌های نمادین، تگ‌ها، . . .) باید
از مجموعه کاراکتر ascii استفاده کنند. رشته‌های لیترال، یعنی متن بین نقل قول‌ها، ممکن است در
ascii گسترش یافته باشند، مانند یکی از مجموعه‌های استاندارد شده در هنجار ISO 8859 —ISO 8859-1
مجموعه "Latin 1" شناخته شده است.

کامپایلر PAWN همچنین از فایل‌های متنی کدگذاری شده UTF-8 پشتیبانی می‌کند، که در
محیطی بر اساس یونیکد یا UCS-4 عملی هستند. کامپایلر PAWN فقط
کاراکترهای کدگذاری شده UTF-8 را در رشته‌های غیر فشرده و ثابت‌های کاراکتری
تشخیص می‌دهد. کامپایلر قوانین نحوی را برای فایل‌های UTF-8 به طور
سختگیرانه تفسیر می‌کند؛ فایل‌های UTF-8 غیر منطبق شناخته نمی‌شوند. فایل ورودی ممکن است، اما
نیازی نیست، یک امضای "Byte Order Mark" داشته باشد؛ کامپایلر
فرمت UTF-8 را بر اساس محتوای فایل تشخیص می‌دهد.

### • گزینه‌ها

گزینه‌ها با یک خط تیره ("-") یا، در Microsoft Windows و DOS، با یک
اسلش رو به جلو ("/") شروع می‌شوند. به عبارت دیگر، همه پلتفرم‌ها یک گزینه نوشته شده
به صورت "-a" را می‌پذیرند (برای هدف این گزینه به زیر مراجعه کنید) و پلتفرم‌های
DOS/Windows "/a" را به عنوان یک روش جایگزین برای نوشتن "-a" می‌پذیرند.

همه گزینه‌ها باید حداقل با یک فاصله جدا شوند.

بسیاری از گزینه‌ها یک مقدار را می‌پذیرند —که گاهی اوقات اجباری است. یک مقدار ممکن است
از حرف گزینه با یک دو نقطه یا یک علامت مساوی (یک ":" و یک "="
به ترتیب) جدا شود، یا مقدار ممکن است به حرف گزینه چسبیده باشد. سه گزینه معادل
برای تنظیم سطح اشکال‌زدایی به دو عبارتند از:

- -d2

- -d:2

- -d=2

گزینه‌ها عبارتند از:

| گزینه | توضیحات |
| ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| -a | اسمبلر: به جای کد باینری، یک فایل متنی با کد شبه-اسمبلر برای ماشین انتزاعی PAWN تولید کنید. |
| -C+/- | کدگذاری فشرده فایل باینری، که اندازه فایل خروجی را معمولاً به کمتر از نصف اندازه اصلی کاهش می‌دهد. از -C+ برای فعال کردن آن و -C- برای غیرفعال کردن آن استفاده کنید. به طور پیش‌فرض، کدگذاری فشرده فعال است. |
| -c | کدپیج: به کامپایلر اجازه می‌دهد تا کاراکترهای ascii گسترش یافته را در رشته‌های لیترال و ثابت‌های کاراکتری ترجمه کند. این گزینه یک مقدار اجباری دارد: نام یک فایل نگاشت کدپیج. |
| -d | اشکال‌زدایی: اطلاعات اشکال‌زدایی را در فایل خروجی قرار دهید. این گزینه یک مقدار اختیاری دارد: سطح اشکال‌زدایی. سطح اشکال‌زدایی 2 (یا بالاتر) اطلاعات خط به خط را در فایل خروجی قرار می‌دهد. سطح اشکال‌زدایی 1 فقط اطلاعات سرآیند را در فایل خروجی قرار می‌دهد. سطح اشکال‌زدایی 0 اطلاعات اشکال‌زدایی را غیرفعال می‌کند. سطح اشکال‌زدایی پیش‌فرض 2 است. |
| -e | نام فایل خروجی: نام فایل خروجی را تنظیم کنید. این گزینه یک مقدار اجباری دارد: نام فایل خروجی. |
| -H | نام فایل سرآیند: نام فایل سرآیند را تنظیم کنید. این گزینه یک مقدار اجباری دارد: نام فایل سرآیند. |
| -i | مسیر شامل: مسیر(های) جستجو برای فایل‌های شامل را تنظیم کنید. این گزینه یک مقدار اجباری دارد: مسیر. چندین مسیر شامل ممکن است با گزینه‌های -i متعدد مشخص شوند. |
| -l | پیوند: یک فایل خروجی را با یک یا چند فایل دیگر پیوند دهید. این گزینه یک مقدار اجباری دارد: نام فایل. چندین فایل ممکن است با گزینه‌های -l متعدد مشخص شوند. |
| -o | پیمایش: کامپایلر را مجبور کنید تا فایل خروجی را حتی اگر کامپایلر خطاها را تشخیص دهد، تولید کند. این گزینه برای اشکال‌زدایی مفید است. |
| -p | مسیر خروجی: مسیر برای همه فایل‌های خروجی را تنظیم کنید. این گزینه یک مقدار اجباری دارد: مسیر. |
| -r | گزارش: سطح گزارش‌دهی را تنظیم کنید. این گزینه یک مقدار اختیاری دارد: سطح گزارش. سطح گزارش 0 تمام گزارش‌ها را غیرفعال می‌کند. سطح گزارش 1 فقط گزارش‌های خلاصه را فعال می‌کند. سطح گزارش 2 گزارش‌های خلاصه و گزارش‌های استفاده از نماد را فعال می‌کند. سطح گزارش 3 گزارش‌های خلاصه، گزارش‌های استفاده از نماد و گزارش‌های استفاده از پیش‌پردازنده را فعال می‌کند. سطح گزارش پیش‌فرض 1 است. |
| -S | سطح بررسی نحوی: سطح بررسی نحوی را تنظیم کنید. این گزینه یک مقدار اختیاری دارد: سطح بررسی. سطح بررسی 0 فقط خطاها را گزارش می‌دهد. سطح بررسی 1 خطاها و هشدارها را گزارش می‌دهد. سطح بررسی 2 خطاها، هشدارها و اطلاعات را گزارش می‌کند. سطح بررسی پیش‌فرض 1 است. |
| -s | اندازه پشته: اندازه پشته و هیپ را تنظیم کنید. این گزینه یک مقدار اجباری دارد: اندازه پشته در سلول‌ها. |
| -t | اندازه تب: اندازه تب را تنظیم کنید. این گزینه یک مقدار اجباری دارد: اندازه تب در کاراکترها. اندازه تب پیش‌فرض 8 است. |
| -v | ساکت: کامپایلر را مجبور کنید تا کمتر پرحرف باشد. |
| -w | هشدارها: هشدارها را به عنوان خطاها در نظر بگیرید. |
| -X | XML: یک فایل XML با اطلاعات نماد تولید کنید. این گزینه یک مقدار اختیاری دارد: نام فایل XML. |
| -\\ | خط ادامه: کاراکتر ادامه خط را تغییر دهید. این گزینه یک مقدار اجباری دارد: کاراکتر ادامه خط. کاراکتر ادامه خط پیش‌فرض بک‌اسلش ("\\") است. |
| -^ | نقطه ویرگول اختیاری: نقطه ویرگول‌های اختیاری را فعال کنید. |
| -; | نقطه ویرگول اختیاری: نقطه ویرگول‌های اختیاری را فعال کنید. |
| -( | کاراکتر آکولاد باز: کاراکتر آکولاد باز را تغییر دهید. این گزینه یک مقدار اجباری دارد: کاراکتر آکولاد باز. کاراکتر آکولاد باز پیش‌فرض "{" است. |
| -) | کاراکتر آکولاد بسته: کاراکتر آکولاد بسته را تغییر دهید. این گزینه یک مقدار اجباری دارد: کاراکتر آکولاد بسته. کاراکتر آکولاد بسته پیش‌فرض "}" است. |

### • فایل پاسخ

اگر خط فرمان با @ شروع شود، متن باقیمانده به عنوان نام فایل تفسیر می‌شود که
گزینه‌های خط فرمان را در خود دارد. این "فایل پاسخ" می‌تواند گزینه‌های خط فرمان و نام‌های فایل را
در چندین خط داشته باشد. خطوط خالی نادیده گرفته می‌شوند و خطوطی که با نقطه ویرگول شروع می‌شوند
به عنوان توضیح در نظر گرفته می‌شوند.

### • فایل خروجی

کامپایلر PAWN یک فایل باینری تولید می‌کند که شامل کد P برای ماشین انتزاعی
PAWN است. پسوند پیش‌فرض برای فایل خروجی ".amx" است. فایل خروجی
ممکن است به یک برنامه میزبان ارسال شود که ماشین انتزاعی PAWN را پیاده‌سازی می‌کند.

با گزینه -a، کامپایلر یک فایل متنی با کد شبه-اسمبلر تولید می‌کند. این
فایل متنی ممکن است برای اشکال‌زدایی مفید باشد، اما نمی‌تواند توسط برنامه میزبان اجرا شود.

### • فایل سرآیند

کامپایلر PAWN می‌تواند یک فایل سرآیند تولید کند که شامل تمام ثابت‌های نمادین عمومی،
متغیرها و تعاریف تابع است. این فایل سرآیند ممکن است توسط برنامه میزبان استفاده شود
تا به ثابت‌ها و توابع عمومی دسترسی پیدا کند. پسوند پیش‌فرض برای فایل سرآیند ".inc" است.

### • فایل XML

کامپایلر PAWN می‌تواند یک فایل XML تولید کند که شامل اطلاعات نماد است. این
فایل XML ممکن است توسط ابزارهای خارجی برای تجزیه و تحلیل اسکریپت استفاده شود. پسوند پیش‌فرض
برای فایل XML ".xml" است.

### • فایل نگاشت کدپیج

فایل نگاشت کدپیج یک فایل متنی است که نگاشت بین کاراکترهای ascii گسترش یافته و
کاراکترهای یونیکد را تعریف می‌کند. این فایل توسط گزینه -c استفاده می‌شود.

فرمت فایل نگاشت کدپیج ساده است: هر خط شامل یک کد کاراکتر ascii گسترش یافته و
کد کاراکتر یونیکد مطابق است، هر دو به صورت عددی. خطوط خالی نادیده گرفته می‌شوند و
خطوطی که با نقطه ویرگول شروع می‌شوند به عنوان توضیح در نظر گرفته می‌شوند.

### • پیوند

کامپایلر PAWN می‌تواند چندین فایل را با هم پیوند دهد. این ویژگی برای ساخت
کتابخانه‌های تابع مفید است. برای پیوند دادن چندین فایل، از گزینه -l استفاده کنید.

### • اشکال‌زدایی

کامپایلر PAWN می‌تواند اطلاعات اشکال‌زدایی را در فایل خروجی قرار دهد. این
اطلاعات ممکن است توسط برنامه میزبان برای اشکال‌زدایی اسکریپت استفاده شود. برای قرار دادن
اطلاعات اشکال‌زدایی در فایل خروجی، از گزینه -d استفاده کنید.

### • گزارش‌ها

کامپایلر PAWN می‌تواند گزارش‌های مختلفی تولید کند. این گزارش‌ها ممکن است برای
اشکال‌زدایی و تجزیه و تحلیل اسکریپت مفید باشند. برای تنظیم سطح گزارش‌دهی، از گزینه -r استفاده کنید.

### • بررسی نحوی

کامپایلر PAWN می‌تواند سطوح مختلفی از بررسی نحوی را انجام دهد. برای تنظیم
سطح بررسی نحوی، از گزینه -S استفاده کنید.

### • اندازه پشته

کامپایلر PAWN می‌تواند اندازه پشته و هیپ را تنظیم کند. این اندازه در سلول‌ها
اندازه‌گیری می‌شود. برای تنظیم اندازه پشته، از گزینه -s استفاده کنید.

### • اندازه تب

کامپایلر PAWN می‌تواند اندازه تب را تنظیم کند. این اندازه در کاراکترها
اندازه‌گیری می‌شود. برای تنظیم اندازه تب، از گزینه -t استفاده کنید.

### • نقطه ویرگول‌های اختیاری

کامپایلر PAWN می‌تواند نقطه ویرگول‌های اختیاری را فعال کند. این ویژگی به شما
اجازه می‌دهد تا نقطه ویرگول‌ها را در انتهای دستورات حذف کنید. برای فعال کردن
نقطه ویرگول‌های اختیاری، از گزینه -^ یا -; استفاده کنید.

### • کاراکترهای آکولاد

کامپایلر PAWN می‌تواند کاراکترهای آکولاد را تغییر دهد. این ویژگی به شما
اجازه می‌دهد تا از کاراکترهای دیگری به جای "{" و "}" استفاده کنید. برای تغییر
کاراکترهای آکولاد، از گزینه‌های -( و -) استفاده کنید.

### • کاراکتر ادامه خط

کامپایلر PAWN می‌تواند کاراکتر ادامه خط را تغییر دهد. این ویژگی به شما
اجازه می‌دهد تا از کاراکتر دیگری به جای "\\" استفاده کنید. برای تغییر
کاراکتر ادامه خط، از گزینه -\\ استفاده کنید.

---

## کدهای خطای زمان اجرا

---

هنگامی که یک اسکریپت PAWN اجرا می‌شود، ممکن است خطاهای زمان اجرا رخ دهند. این
خطاها توسط ماشین انتزاعی PAWN تشخیص داده می‌شوند و ممکن است توسط برنامه میزبان
گزارش شوند. کدهای خطای زمان اجرا عبارتند از:

| کد | توضیحات |
| --- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 1 | **خارج از محدوده پشته** |
| | اشاره‌گر پشته از محدوده پشته فراتر رفته است. این خطا معمولاً توسط بازگشت‌های بیش از حد عمیق یا متغیرهای محلی بیش از حد زیاد ایجاد می‌شود. |
| 2 | **خارج از محدوده هیپ** |
| | اشاره‌گر هیپ از محدوده هیپ فراتر رفته است. این خطا معمولاً توسط تخصیص حافظه بیش از حد زیاد ایجاد می‌شود. |
| 3 | **شاخص آرایه نامعتبر** |
| | یک شاخص آرایه خارج از محدوده آرایه است. |
| 4 | **فایل نامعتبر** |
| | یک فایل نامعتبر به یک تابع بومی ارسال شده است. |
| 5 | **دسترسی به حافظه نامعتبر** |
| | یک تابع بومی سعی کرده است به حافظه خارج از محدوده اسکریپت دسترسی پیدا کند. |
| 6 | **دستورالعمل نامعتبر** |
| | یک دستورالعمل نامعتبر در اسکریپت یافت شده است. این خطا معمولاً توسط یک فایل خروجی خراب ایجاد می‌شود. |
| 7 | **تابع بومی نامعتبر** |
| | یک تابع بومی نامعتبر فراخوانی شده است. این خطا معمولاً توسط یک فایل خروجی خراب یا یک برنامه میزبان ناسازگار ایجاد می‌شود. |
| 8 | **تابع عمومی نامعتبر** |
| | یک تابع عمومی نامعتبر فراخوانی شده است. این خطا معمولاً توسط یک فایل خروجی خراب یا یک برنامه میزبان ناسازگار ایجاد می‌شود. |
| 9 | **تقسیم بر صفر** |
| | یک تقسیم بر صفر رخ داده است. |
| 10 | **حلقه بی‌نهایت** |
| | یک حلقه بی‌نهایت تشخیص داده شده است. این خطا معمولاً توسط یک حلقه بدون شرط خروج ایجاد می‌شود. |
| 11 | **نامعتبر است** |
| | یک عملیات نامعتبر رخ داده است. این خطا معمولاً توسط یک فایل خروجی خراب ایجاد می‌شود. |
| 12 | **حافظه ناکافی** |
| | حافظه ناکافی برای اجرای اسکریپت وجود دارد. این خطا معمولاً توسط یک اسکریپت بیش از حد بزرگ یا تخصیص حافظه بیش از حد زیاد ایجاد می‌شود. |
| 13 | **فرمت نامعتبر** |
| | فرمت فایل خروجی نامعتبر است. این خطا معمولاً توسط یک فایل خروجی خراب ایجاد می‌شود. |
| 14 | **پیاده‌سازی نشده** |
| | یک ویژگی پیاده‌سازی نشده فراخوانی شده است. |
| 15 | **حافظه نامعتبر** |
| | یک آدرس حافظه نامعتبر به یک تابع بومی ارسال شده است. |
| 16 | **تابع حالت نامعتبر** |
| | یک تابع حالت نامعتبر فراخوانی شده است. این خطا معمولاً زمانی رخ می‌دهد که یک تابع برای حالت فعلی پیاده‌سازی نشده است. |
| 17 | **حالت نامعتبر** |
| | یک حالت نامعتبر درخواست شده است. این خطا معمولاً زمانی رخ می‌دهد که یک حالت تعریف نشده درخواست شده است. |
| 18 | **اتوماتون نامعتبر** |
| | یک اتوماتون نامعتبر درخواست شده است. این خطا معمولاً زمانی رخ می‌دهد که یک اتوماتون تعریف نشده درخواست شده است. |

---

## کلمات رزرو شده

---
